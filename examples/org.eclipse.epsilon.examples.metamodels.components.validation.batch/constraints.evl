pre StartTime{
	var system = Native('java.lang.System');
	var start = system.currentTimeMillis();
	}
post EndTime{
	var end = system.currentTimeMillis();
	(end - start).println('elapsed millis: ');
	}

context ccl::Connector {
	
  constraint ConnectorSourceTargetNotSameComponent {      	  	
    guard: self.source.isDefined() and self.target.isDefined()
    check {	(self.source.eContainer.name + " != " + self.target.eContainer.name).println("ConnectorSourceTargetNotSameComponent:  ");
			return self.source.eContainer <> self.target.eContainer;}
    message: "Connectors must link different components"    
  }
  
  constraint ConnectorMustHaveSource{
  	check {	(self.source.name + " source " + self.source.isDefined()).println("ConnectorMustHaveSource: " );
			return self.source.isDefined(); }
  	message: "Connector must have a Source port"
  }
  
    constraint ConnectorMustHaveTarget{
  	check {	(self.target.name + " target " + self.target.isDefined()).println("ConnectorMustHaveTarget: " );
			return self.target.isDefined();} 
  	message: "Connector must have a Target port"
  }
}

context ccl::Component {


	critique ComponentHasValidName {
	check {	(self.name).println("ComponentHasValidName: " );
			return self.name = self.name.firstToUpperCase();}
	message: self.name + " should start with an upper-case letter"
	}
	
	constraint ComponentHasPorts {
    	check {	(self.name + " has " +  self.ports.size()+ " Ports").println("ComponentHasPorts: ");
				return self.ports.notEmpty();}
    	message: self.name + "has no Ports"
    }
    /*
    constraint ComponentLoops {
    check { 
    	for (p : Port  in self.ports) {
    		var list = p.closure(c | p.component.ports);
    		list.print();
    		p.name.println("Port: ");
    		}
    	//list.println(" ComponentLoops List: ");
    	return false;}

    message: "Loop found"
    }*/
    
    constraint ComponentLoops {
    check { 
    		//var c = StepNext(self.ports[0]);
    		var list = self.closure(c : Component | c.ports.connector.source.component);
    		list.contains(self).println("Loop: ");
    		self.name.print("Component: ");
    		list.println(" list: ");
    		//var list = self.ports[0].closure(c | StepNext(c.ports[0]);
    		//self.name.print("1, ");
    		//c.name.println(" 2, ");
    		//self.name.print();
    		//var list = self.ports.closure(c : OutPort | c.connector.target);
    		//list.println(" : ");    		
    		//list.println(" ComponentLoops List: ");
    		return false;}

    message: "Loop found"
    }
    
    
    

    
    /*
    constraint ComponentHasUniqueName {
        check {	(self.name).println("ComponentHasUniqueName: ");
				return Component.all.select(x|x.name = self.name).size() < 2;}
        message: "Duplicate component name " + self.name
    }
    
    critique ComponentIsConnected {
        check {	(self.name).println("ComponentIsConnected: ");
				return Connector.all.exists(x|self.ports.includes(x.source)
            		or self.ports.includes(x.target));}
        message: "Component " + self.name + " is disconnected"
    } 
	*/ 
}

operation StepNext (p : Port) : ccl::Component {
	p.connector.source.name.print("source port: ");
	p.connector.source.component.name.println(" on component: ");
	return p.connector.source.component;
}





// Ideas for constraints:

// Indirect cycles
// Warnings about components without ports
// Warnings about unused ports