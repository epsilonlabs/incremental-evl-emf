pre StartTime{
	var system = Native('java.lang.System');
	var start = system.currentTimeMillis();
	}
post EndTime{
	var end = system.currentTimeMillis();
	(end - start).println('elapsed millis: ');
	}

context ccl::Connector {
	
  constraint ConnectorSourceTargetNotSameComponent {      	  	
    guard: self.source.isDefined() and self.target.isDefined()
    check {	(self.source.eContainer.name + " != " + self.target.eContainer.name).println("ConnectorSourceTargetNotSameComponent:  ");
			return self.source.eContainer <> self.target.eContainer;}
    message: "Connectors must link different components"    
  }
  
  constraint ConnectorMustHaveSource{    
  	check {	self.id.print("ConnectorMustHaveSource: ");
  			if(self.source.isDefined()) 
  			{
  				(self.source.component.name + "-" + self.source.name ).println(" > ");
  			}
  			else {
  				"no source".println(" > ");
  			}
			return self.source.isDefined(); }
  	message: "Connector must have a Source port"
  }
  
    constraint ConnectorMustHaveTarget{
  	check {	//(self.target.name + " target " + self.target.isDefined()).println("ConnectorMustHaveTarget: " );
			self.id.print("ConnectorMustHaveTarget: ");
			if(self.target.isDefined())
			{
				(self.target.component.name + "-" + self.target.name ).println(" > ");
			}
			else
			{
				"no target".println(" > ");
			}
			
			return self.target.isDefined();} 
  	message: "Connector must have a Target port"
  }
}

context ccl::Component {

	constraint ComponentNameExists {
		check { (self.name.isDefined + " " + self.id).println("ComponentNameExists: " );
				return self.name.isDefined();}
		message: "Component with no name: " + self.id
	}


	critique ComponentHasValidName {
		guard: self.name.isDefined()
		check {	(self.name).println("ComponentHasValidName: " );
				return self.name = self.name.firstToUpperCase();}
		message: self.name + " should start with an upper-case letter"
	}
	
	constraint ComponentHasPorts {
    	check {	(self.name + " has " +  self.ports.size()+ " Ports").println("ComponentHasPorts: ");
				return self.ports.notEmpty();}
    	message: self.name + "has no Ports"
    }
    
    constraint ComponentLoops {
    check { self.name.print("ComponentLoops: ");
    		var list = self.closure(c : Component | c.ports.select(p|p.isKindOf(InPort)
    			and p.connector.isDefined() 
    			and p.connector.source.isDefined()).connector.source.component);
    		if(list.contains(self)) {
    			list.println(" loop: ");
    		}
    		else {
    			"none".println(" loop: ");
    		}
    		return not list.contains(self);}
    message: "Loop found: " + list
    }
    
    /* Component names must be globally unique */
    constraint UniqueName {        
        check	: getComponentsByName().get(self.name).size() == 1
        message : "Duplicate component name " + self.name
    }  
    
    critique ComponentIsConnected {
	    check	{	//(self.name).println("ComponentIsConnected: ");
	    			return self.ports.exists(p | p.connector.isDefined());}
	    message: "Component " + self.name + " is disconnected"
    }
}

@cached
operation getComponentsByName() {
    return Component.all.mapBy(c|c.name);
}



// Ideas for constraints:

// Indirect cycles
// Warnings about components without ports
// Warnings about unused ports