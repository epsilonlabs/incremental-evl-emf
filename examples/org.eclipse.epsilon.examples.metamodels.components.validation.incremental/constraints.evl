pre StartTime{
	var system = Native('java.lang.System');
	var start = system.currentTimeMillis();
	}
post EndTime{
	var end = system.currentTimeMillis();
	(end - start).println('elapsed millis: ');
	}

context ccl::Connector {
	
  constraint ConnectorSourceTargetNotSameComponent {      	  	
    guard: self.source.isDefined() and self.target.isDefined()
    check {	(self.source.eContainer.name + " != " + self.target.eContainer.name).println("ConnectorSourceTargetNotSameComponent:  ");
			return self.source.eContainer <> self.target.eContainer;}
    message: "Connectors must link different components"    
  }
  
  constraint ConnectorMustHaveSource{
  	check {	(self.source.name + " source " + self.source.isDefined()).println("ConnectorMustHaveSource: " );
			return self.source.isDefined(); }
  	message: "Connector must have a Source port"
  }
  
    constraint ConnectorMustHaveTarget{
  	check {	(self.target.name + " target " + self.target.isDefined()).println("ConnectorMustHaveTarget: " );
			return self.target.isDefined();} 
  	message: "Connector must have a Target port"
  }
}

context ccl::Component {


	critique ComponentHasValidName {
	check {	(self.name).println("ComponentHasValidName: " );
			return self.name = self.name.firstToUpperCase();}
	message: self.name + " should start with an upper-case letter"
	}
	
	constraint ComponentHasPorts {
    	check {	(self.name + " has " +  self.ports.size()+ " Ports").println("ComponentHasPorts: ");
				return self.ports.notEmpty();}
    	message: self.name + "has no Ports"
    }
    
    constraint ComponentLoops {
    check {var list = self.closure(i|i.ports);
    	list.println(" ComponentLoops List: ");
    	return list.contains(self);
     }
    message: "Loop found"
    }
    
    /*
    constraint ComponentHasUniqueName {
        check {	(self.name).println("ComponentHasUniqueName: ");
				return Component.all.select(x|x.name = self.name).size() < 2;}
        message: "Duplicate component name " + self.name
    }
    
    critique ComponentIsConnected {
        check {	(self.name).println("ComponentIsConnected: ");
				return Connector.all.exists(x|self.ports.includes(x.source)
            		or self.ports.includes(x.target));}
        message: "Component " + self.name + " is disconnected"
    } 
	*/
	   
}




// Ideas for constraints:

// Indirect cycles
// Warnings about components without ports
// Warnings about unused ports