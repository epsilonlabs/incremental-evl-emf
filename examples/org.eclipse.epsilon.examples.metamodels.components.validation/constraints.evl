context ccl::Connector {
  constraint SourceTargetMustBeDifferentComponents {
    guard: self.source.isDefined() and self.target.isDefined()
    check: self.source.eContainer <> self.target.eContainer
    message: "Connectors must link different components"
  }
}

context ccl::Component {
	constraint UniqueName {
        check: Component.all.select(c|c.name = self.name).size() < 2
        message: "Duplicate component name " + self.name
    }

	critique ValidName {
		check: self.name = self.name.firstToUpperCase()
		message: self.name + " should start with an upper-case letter"
	}
    
    critique IsConnected {
        check: Connector.all.exists(c|self.ports.includes(c.source)
            or self.ports.includes(c.target))
        message: "Component " + self.name + " is disconnected"
    }
    
    constraint NoPorts {
    	check: self.ports.notEmpty()
    	message: self.name + "has no Ports"
    }
    
}

// Ideas for constraints:

// Indirect cycles
// Warnings about components without ports
// Warnings about unused ports